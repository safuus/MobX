<?xml version='1.0'?>
<!-- NOTE: this file is autogenerated by Apache XBean -->

<xs:schema elementFormDefault='qualified'
           targetNamespace='http://mina.apache.org/config/1.0'
           xmlns:xs='http://www.w3.org/2001/XMLSchema'
           xmlns:tns='http://mina.apache.org/config/1.0'>

  <!-- element for type: org.apache.mina.filter.firewall.BlacklistFilter -->
  <xs:element name='blacklistFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A {@link IoFilter} which blocks connections from blacklisted remote
address.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='blacklist' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the addresses to be blacklisted.

NOTE: this call will remove any previously blacklisted addresses.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='subnetBlacklist' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the subnets to be blacklisted.

NOTE: this call will remove any previously blacklisted subnets.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='blacklist' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the addresses to be blacklisted.

NOTE: this call will remove any previously blacklisted addresses.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='subnetBlacklist' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the subnets to be blacklisted.

NOTE: this call will remove any previously blacklisted subnets.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.buffer.BufferedWriteFilter -->
  <xs:element name='bufferedWriteFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An {@link IoFilter} implementation used to buffer outgoing {@link WriteRequest} almost
like what {@link BufferedOutputStream} does. Using this filter allows to be less dependent
from network latency. It is also useful when a session is generating very small messages
too frequently and consequently generating unnecessary traffic overhead.

Please note that it should always be placed before the {@link ProtocolCodecFilter}
as it only handles {@link WriteRequest}'s carrying {@link IoBuffer} objects.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='buffersMap' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              the map to use for storing each session buffer
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='bufferSize' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns buffer size.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='buffersMap' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the map to use for storing each session buffer
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder -->
  <xs:element name='defaultIoFilterChainBuilder'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        The default implementation of {@link IoFilterChainBuilder} which is useful
in most cases. {@link DefaultIoFilterChainBuilder} has an identical interface
with {@link IoFilter}; it contains a list of {@link IoFilter}s that you can
modify. The {@link IoFilter}s which are added to this builder will be appended
to the {@link IoFilterChain} when {@link #buildFilterChain(IoFilterChain)} is
invoked.
<p>
However, the identical interface doesn't mean that it behaves in an exactly
same way with {@link IoFilterChain}. {@link DefaultIoFilterChainBuilder}
doesn't manage the life cycle of the {@link IoFilter}s at all, and the
existing {@link IoSession}s won't get affected by the changes in this builder.
{@link IoFilterChainBuilder}s affect only newly created {@link IoSession}s.

<pre>
IoAcceptor acceptor = ...;
DefaultIoFilterChainBuilder builder = acceptor.getFilterChain();
builder.addLast( "myFilter", new MyFilter() );
...
</pre>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='filterChain' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:defaultIoFilterChainBuilder'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='filters' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Clears the current list of filters and adds the specified
filter mapping to this builder. Please note that you must specify
a {@link Map} implementation that iterates the filter mapping in the
order of insertion such as {@link LinkedHashMap}. Otherwise, it will
throw an {@link IllegalArgumentException}.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='filterChain' type='xs:string'/>
      <xs:attribute name='filters' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Clears the current list of filters and adds the specified
filter mapping to this builder. Please note that you must specify
a {@link Map} implementation that iterates the filter mapping in the
order of insertion such as {@link LinkedHashMap}. Otherwise, it will
throw an {@link IllegalArgumentException}.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.errorgenerating.ErrorGeneratingFilter -->
  <xs:element name='errorGeneratingFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An {@link IoFilter} implementation generating random bytes and PDU modification in
your communication streams.
It's quite simple to use :
<code>ErrorGeneratingFilter egf = new ErrorGeneratingFilter();</code>
For activate the change of some bytes in your {@link IoBuffer}, for a probability of 200 out
of 1000 {@link IoBuffer} processed :
<code>egf.setChangeByteProbability(200);</code>
For activate the insertion of some bytes in your {@link IoBuffer}, for a
probability of 200 out of 1000 :
<code>egf.setInsertByteProbability(200);</code>
And for the removing of some bytes :
<code>egf.setRemoveByteProbability(200);</code>
You can activate the error generation for write or read with the
following methods :
<code>egf.setManipulateReads(true);
egf.setManipulateWrites(true); </code>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='changeByteProbability' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the probability for the change byte error.
If this probability is > 0 the filter will modify a random number of byte
of the processed {@link IoBuffer}.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='duplicatePduProbability' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            not functional ATM
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='insertByteProbability' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the probability for the insert byte error.
If this probability is > 0 the filter will insert a random number of byte
in the processed {@link IoBuffer}.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='manipulateReads' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set to true if you want to apply error to the read {@link IoBuffer}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='manipulateWrites' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set to true if you want to apply error to the written {@link IoBuffer}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maxInsertByte' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the maximum number of byte the filter can insert in a {@link IoBuffer}.
The default value is 10.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='removeByteProbability' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Set the probability for the remove byte error.
If this probability is > 0 the filter will remove a random number of byte
in the processed {@link IoBuffer}.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='removePduProbability' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            not functional ATM
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='resendPduLasterProbability' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            not functional ATM
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.executor.ExecutorFilter -->
  <xs:element name='executorFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A filter that forwards I/O events to {@link Executor} to enforce a certain
thread model while allowing the events per session to be processed
simultaneously. You can apply various thread model by inserting this filter
to a {@link IoFilterChain}.

<h2>Life Cycle Management</h2>

Please note that this filter doesn't manage the life cycle of the {@link Executor}.
If you created this filter using {@link #ExecutorFilter(Executor)} or similar
constructor that accepts an {@link Executor} that you've instantiated, you have
full control and responsibility of managing its life cycle (e.g. calling
{@link ExecutorService#shutdown()}.
<p>
If you created this filter using convenience constructors like
{@link #ExecutorFilter(int)}, then you can shut down the executor by calling
{@link #destroy()} explicitly.

<h2>Event Ordering</h2>

All convenience constructors of this filter creates a new
{@link OrderedThreadPoolExecutor} instance. Therefore, the order of event is
maintained like the following:
<ul>
<li>All event handler methods are called exclusively.
(e.g. messageReceived and messageSent can't be invoked at the same time.)</li>
<li>The event order is never mixed up.
(e.g. messageReceived is always invoked before sessionClosed or messageSent.)</li>
</ul>
However, if you specified other {@link Executor} instance in the constructor,
the order of events are not maintained at all. This means more than one event
handler methods can be invoked at the same time with mixed order. For example,
let's assume that messageReceived, messageSent, and sessionClosed events are
fired.
<ul>
<li>All event handler methods can be called simultaneously.
(e.g. messageReceived and messageSent can be invoked at the same time.)</li>
<li>The event order can be mixed up.
(e.g. sessionClosed or messageSent can be invoked before messageReceived
is invoked.)</li>
</ul>
If you need to maintain the order of events per session, please specify an
{@link OrderedThreadPoolExecutor} instance or use the convenience constructors.

<h2>Selective Filtering</h2>

By default, all event types but <tt>sessionCreated</tt>, <tt>filterWrite</tt>,
<tt>filterClose</tt> and <tt>filterSetTrafficMask</tt> are submitted to the
underlying executor, which is most common setting.
<p>
If you want to submit only a certain set of event types, you can specify them
in the constructor. For example, you could configure a thread pool for
write operation for the maximum performance:
<pre><code>
IoService service = ...;
DefaultIoFilterChainBuilder chain = service.getFilterChain();

chain.addLast("codec", new ProtocolCodecFilter(...));
// Use one thread pool for most events.
chain.addLast("executor1", new ExecutorFilter());
// and another dedicated thread pool for 'filterWrite' events.
chain.addLast("executor2", new ExecutorFilter(IoEventType.WRITE));
</code></pre>

<h2>Preventing {@link OutOfMemoryError}</h2>

Please refer to {@link IoEventQueueThrottle}, which is specified as
a parameter of the convenience constructors.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='eventTypes' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The event for which the executor will be used
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Returns the underlying {@link Executor} instance this filter uses.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:standardThreadPool'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='queueHandler' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The queue used to store events
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='threadFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The factory used to create threads
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='unit' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Time unit used for the keepAlive value
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='corePoolSize' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The initial pool size
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='eventTypes' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The event for which the executor will be used
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='executor' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns the underlying {@link Executor} instance this filter uses.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='keepAliveTime' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Default duration for a thread
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maximumPoolSize' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The maximum pool size
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='queueHandler' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The queue used to store events
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='threadFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The factory used to create threads
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='unit' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Time unit used for the keepAlive value
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.core.session.ExpiringSessionRecycler -->
  <xs:element name='expiringSessionRecycler'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An {@link IoSessionRecycler} with sessions that time out on inactivity.

TODO Document me.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='expirationInterval' type='xs:integer'/>
      <xs:attribute name='timeToLive' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.stream.FileRegionWriteFilter -->
  <xs:element name='fileRegionWriteFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Filter implementation that converts a {@link FileRegion} to {@link IoBuffer}
objects and writes those buffers to the next filter. When end of the
{@code FileRegion} has been reached this filter will call
{@link IoFilter.NextFilter#messageSent(IoSession,WriteRequest)} using the
original {@link FileRegion} written to the session and notifies
{@link org.apache.mina.core.future.WriteFuture} on the original
{@link org.apache.mina.core.write.WriteRequest}.
<p>Normall {@code FileRegion} objects should be handled by the
{@link org.apache.mina.core.service.IoProcessor} but this is not always possible
if a filter is being used that needs to modify the contents of the file
before sending over the network (i.e. the
{@link org.apache.mina.filter.ssl.SslFilter} or a data compression filter.)
</p>
<p> This filter will ignore written messages which aren't {@link FileRegion}
instances. Such messages will be passed to the next filter directly.
</p>
<p><b>NOTE:</b> this filter does not close the file channel in
{@link FileRegion#getFileChannel()} after the data from the file has been
written. The {@code FileChannel} should be closed in either
{@link org.apache.mina.core.service.IoHandler#messageSent(IoSession,Object)}
or in an {@link org.apache.mina.core.future.IoFutureListener} associated with the
{@code WriteFuture}.
</p>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='writeBufferSize' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns the size of the write buffer in bytes. Data will be read from the
stream in chunks of this size and then written to the next filter.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.keepalive.KeepAliveFilter -->
  <xs:element name='keepAliveFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An {@link IoFilter} that sends a keep-alive request on
{@link IoEventType#SESSION_IDLE} and sends back the response for the
sent keep-alive request.

<h2>Interference with {@link IoSessionConfig#setIdleTime(IdleStatus, int)}</h2>

This filter adjusts <tt>idleTime</tt> of the {@link IdleStatus}s that
this filter is interested in automatically (e.g. {@link IdleStatus#READER_IDLE}
and {@link IdleStatus#WRITER_IDLE}.) Changing the <tt>idleTime</tt>
of the {@link IdleStatus}s can lead this filter to a unexpected behavior.
Please also note that any {@link IoFilter} and {@link IoHandler} behind
{@link KeepAliveFilter} will not get any {@link IoEventType#SESSION_IDLE}
event. To receive the internal {@link IoEventType#SESSION_IDLE} event,
you can call {@link #setForwardEvent(boolean)} with <tt>true</tt>.

<h2>Implementing {@link KeepAliveMessageFactory}</h2>

To use this filter, you have to provide an implementation of
{@link KeepAliveMessageFactory}, which determines a received or sent
message is a keep-alive message or not and creates a new keep-alive
message:

<table border="1">
<tr>
<th>Name</th><th>Description</th><th>Implementation</th>
</tr>
<tr valign="top">
<td>Active</td>
<td>You want a keep-alive request is sent when the reader is idle.
Once the request is sent, the response for the request should be
received within <tt>keepAliveRequestTimeout</tt> seconds. Otherwise,
the specified {@link KeepAliveRequestTimeoutHandler} will be invoked.
If a keep-alive request is received, its response also should be sent back.
</td>
<td>Both {@link KeepAliveMessageFactory#getRequest(IoSession)} and
{@link KeepAliveMessageFactory#getResponse(IoSession, Object)} must
return a non-<tt>null</tt>.</td>
</tr>
<tr valign="top">
<td>Semi-active</td>
<td>You want a keep-alive request to be sent when the reader is idle.
However, you don't really care if the response is received or not.
If a keep-alive request is received, its response should
also be sent back.
</td>
<td>Both {@link KeepAliveMessageFactory#getRequest(IoSession)} and
{@link KeepAliveMessageFactory#getResponse(IoSession, Object)} must
return a non-<tt>null</tt>, and the <tt>timeoutHandler</tt> property
should be set to {@link KeepAliveRequestTimeoutHandler#NOOP},
{@link KeepAliveRequestTimeoutHandler#LOG} or the custom {@link KeepAliveRequestTimeoutHandler}
implementation that doesn't affect the session state nor throw an exception.
</td>
</tr>
<tr valign="top">
<td>Passive</td>
<td>You don't want to send a keep-alive request by yourself, but the
response should be sent back if a keep-alive request is received.</td>
<td>{@link KeepAliveMessageFactory#getRequest(IoSession)} must return
<tt>null</tt> and {@link KeepAliveMessageFactory#getResponse(IoSession, Object)}
must return a non-<tt>null</tt>.</td>
</tr>
<tr valign="top">
<td>Deaf Speaker</td>
<td>You want a keep-alive request to be sent when the reader is idle, but
you don't want to send any response back.</td>
<td>{@link KeepAliveMessageFactory#getRequest(IoSession)} must return
a non-<tt>null</tt>,
{@link KeepAliveMessageFactory#getResponse(IoSession, Object)} must
return <tt>null</tt> and the <tt>timeoutHandler</tt> must be set to
{@link KeepAliveRequestTimeoutHandler#DEAF_SPEAKER}.</td>
</tr>
<tr valign="top">
<td>Silent Listener</td>
<td>You don't want to send a keep-alive request by yourself nor send any
response back.</td>
<td>Both {@link KeepAliveMessageFactory#getRequest(IoSession)} and
{@link KeepAliveMessageFactory#getResponse(IoSession, Object)} must
return <tt>null</tt>.</td>
</tr>
</table>
Please note that you must implement
{@link KeepAliveMessageFactory#isRequest(IoSession, Object)} and
{@link KeepAliveMessageFactory#isResponse(IoSession, Object)} properly
whatever case you chose.

<h2>Handling timeout</h2>

{@link KeepAliveFilter} will notify its {@link KeepAliveRequestTimeoutHandler}
when {@link KeepAliveFilter} didn't receive the response message for a sent
keep-alive message. The default handler is {@link KeepAliveRequestTimeoutHandler#CLOSE},
but you can use other presets such as {@link KeepAliveRequestTimeoutHandler#NOOP},
{@link KeepAliveRequestTimeoutHandler#LOG} or {@link KeepAliveRequestTimeoutHandler#EXCEPTION}.
You can even implement your own handler.

<h3>Special handler: {@link KeepAliveRequestTimeoutHandler#DEAF_SPEAKER}</h3>

{@link KeepAliveRequestTimeoutHandler#DEAF_SPEAKER} is a special handler which is
dedicated for the 'deaf speaker' mode mentioned above. Setting the
<tt>timeoutHandler</tt> property to {@link KeepAliveRequestTimeoutHandler#DEAF_SPEAKER}
stops this filter from waiting for response messages and therefore disables
response timeout detection.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='interestedIdleStatus' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='messageFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='policy' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='requestTimeoutHandler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='forwardEvent' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns <tt>true</tt> if and only if this filter forwards
a {@link IoEventType#SESSION_IDLE} event to the next filter.
By default, the value of this property is <tt>false</tt>.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='interestedIdleStatus' type='xs:string'/>
      <xs:attribute name='keepAliveRequestInterval' type='xs:integer'/>
      <xs:attribute name='keepAliveRequestTimeout' type='xs:integer'/>
      <xs:attribute name='messageFactory' type='xs:string'/>
      <xs:attribute name='policy' type='xs:string'/>
      <xs:attribute name='requestInterval' type='xs:integer'/>
      <xs:attribute name='requestTimeout' type='xs:integer'/>
      <xs:attribute name='requestTimeoutHandler' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.logging.LoggingFilter -->
  <xs:element name='loggingFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Logs all MINA protocol events. Each event can be
tuned to use a different level based on the user's specific requirements. Methods
are in place that allow the user to use either the get or set method for each event
and pass in the {@link IoEventType} and the {@link LogLevel}.

By default, all events are logged to the {@link LogLevel#INFO} level except
{@link IoFilterAdapter#exceptionCaught(IoFilter.NextFilter, IoSession, Throwable)},
which is logged to {@link LogLevel#WARN}.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='exceptionCaughtLogLevel' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the LogLevel for the ExceptionCaught event.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='messageReceivedLogLevel' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the LogLevel for the MessageReceived event.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='messageSentLogLevel' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the LogLevel for the MessageSent event.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sessionClosedLogLevel' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the LogLevel for the SessionClosed event.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sessionCreatedLogLevel' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the LogLevel for the SessionCreated event.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sessionIdleLogLevel' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the LogLevel for the SessionIdle event.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sessionOpenedLogLevel' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Get the LogLevel for the SessionOpened event.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='clazz' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the cass which name will be used to create the logger
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='exceptionCaughtLogLevel' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the LogLevel for the ExceptionCaught event.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='messageReceivedLogLevel' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the LogLevel for the MessageReceived event.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='messageSentLogLevel' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the LogLevel for the MessageSent event.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='name' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            the name used to create the logger. If null, will default to "NoopFilter"
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sessionClosedLogLevel' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the LogLevel for the SessionClosed event.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sessionCreatedLogLevel' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the LogLevel for the SessionCreated event.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sessionIdleLogLevel' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the LogLevel for the SessionIdle event.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sessionOpenedLogLevel' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Get the LogLevel for the SessionOpened event.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.transport.socket.nio.NioDatagramAcceptor -->
  <xs:element name='nioDatagramAcceptor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        {@link IoAcceptor} for datagram transport (UDP/IP).
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='defaultLocalAddress' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='defaultLocalAddresses' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              {@inheritDoc}
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='executor' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:standardThreadPool'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='filterChainBuilder' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              {@inheritDoc}
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:defaultIoFilterChainBuilder'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name='handler' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              {@inheritDoc}
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sessionDataStructureFactory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              {@inheritDoc}
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sessionRecycler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:expiringSessionRecycler'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='closeOnDeactivation' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            {@inheritDoc}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='defaultLocalAddress' type='xs:string'/>
      <xs:attribute name='defaultLocalAddresses' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            {@inheritDoc}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='executor' type='xs:string'/>
      <xs:attribute name='filterChainBuilder' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            {@inheritDoc}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='handler' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            {@inheritDoc}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sessionDataStructureFactory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            {@inheritDoc}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sessionRecycler' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.executor.OrderedThreadPoolExecutor -->
  <xs:element name='orderedThreadPoolExecutor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A {@link ThreadPoolExecutor} that maintains the order of {@link IoEvent}s.
<p>
If you don't need to maintain the order of events per session, please use
{@link UnorderedThreadPoolExecutor}.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='eventQueueHandler' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The queue used to store events
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='rejectedExecutionHandler' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              {@inheritDoc}
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='threadFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='unit' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Time unit used for the keepAlive value
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='corePoolSize' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            {@inheritDoc}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='eventQueueHandler' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The queue used to store events
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='keepAliveTime' type='xs:long'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Default duration for a thread
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='maximumPoolSize' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            {@inheritDoc}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='rejectedExecutionHandler' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            {@inheritDoc}
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='threadFactory' type='xs:string'/>
      <xs:attribute name='unit' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Time unit used for the keepAlive value
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.statistic.ProfilerTimerFilter -->
  <xs:element name='profilerTimerFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        This class will measure the time it takes for a
method in the {@link IoFilterAdapter} class to execute. The basic
premise of the logic in this class is to get the current time
at the beginning of the method, call method on nextFilter, and
then get the current time again. An example of how to use
the filter is:

<pre>
ProfilerTimerFilter profiler = new ProfilerTimerFilter(
TimeUnit.MILLISECOND, IoEventType.MESSAGE_RECEIVED);
chain.addFirst("Profiler", profiler);
</pre>

The profiled {@link IoEventType} are :
<ul>
<li>IoEventType.MESSAGE_RECEIVED</li>
<li>IoEventType.MESSAGE_SENT</li>
<li>IoEventType.SESSION_CREATED</li>
<li>IoEventType.SESSION_OPENED</li>
<li>IoEventType.SESSION_IDLE</li>
<li>IoEventType.SESSION_CLOSED</li>
</ul>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='eventTypes' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              A list of {@link IoEventType} representation of the methods to profile
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='eventsToProfile' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Return the set of {@link IoEventType} which are profiled.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='profilers' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Create the profilers for a list of {@link IoEventType}.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='timeUnit' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the {@link TimeUnit} being used.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='eventTypes' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            A list of {@link IoEventType} representation of the methods to profile
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='eventsToProfile' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Return the set of {@link IoEventType} which are profiled.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='profilers' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Create the profilers for a list of {@link IoEventType}.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='timeUnit' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the {@link TimeUnit} being used.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.codec.ProtocolCodecFilter -->
  <xs:element name='protocolCodecFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An {@link IoFilter} which translates binary or protocol specific data into
message objects and vice versa using {@link ProtocolCodecFactory},
{@link ProtocolEncoder}, or {@link ProtocolDecoder}.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='decoder' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The class responsible for decoding the message
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='encoder' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The class responsible for encoding the message
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='factory' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              The associated factory
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='decoder' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The class responsible for decoding the message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='decoderClass' type='xs:string'/>
      <xs:attribute name='encoder' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The class responsible for encoding the message
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='encoderClass' type='xs:string'/>
      <xs:attribute name='factory' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            The associated factory
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.util.ReferenceCountingFilter -->
  <xs:element name='referenceCountingFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An {@link IoFilter}s wrapper that keeps track of the number of usages of this filter and will call init/destroy
when the filter is not in use.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='filter' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:choice minOccurs='0' maxOccurs='1'>
              <xs:element ref='tns:blacklistFilter'/>
              <xs:element ref='tns:bufferedWriteFilter'/>
              <xs:element ref='tns:errorGeneratingFilter'/>
              <xs:element ref='tns:executorFilter'/>
              <xs:element ref='tns:fileRegionWriteFilter'/>
              <xs:element ref='tns:keepAliveFilter'/>
              <xs:element ref='tns:loggingFilter'/>
              <xs:element ref='tns:profilerTimerFilter'/>
              <xs:element ref='tns:protocolCodecFilter'/>
              <xs:element ref='tns:referenceCountingFilter'/>
              <xs:element ref='tns:requestResponseFilter'/>
              <xs:element ref='tns:sessionAttributeInitializingFilter'/>
              <xs:element ref='tns:sslFilter'/>
              <xs:element ref='tns:streamWriteFilter'/>
              <xs:any namespace='##other'/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='filter' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.reqres.RequestResponseFilter -->
  <xs:element name='requestResponseFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        TODO Add documentation
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='responseInspector' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='responseInspectorFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='timeoutScheduler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='responseInspector' type='xs:string'/>
      <xs:attribute name='responseInspectorFactory' type='xs:string'/>
      <xs:attribute name='timeoutScheduler' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.util.SessionAttributeInitializingFilter -->
  <xs:element name='sessionAttributeInitializingFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An {@link IoFilter} that sets initial attributes when a new
{@link IoSession} is created. By default, the attribute map is empty when
an {@link IoSession} is newly created. Inserting this filter will make
the pre-configured attributes available after this filter executes the
<tt>sessionCreated</tt> event.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='attributes' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Sets the attribute map. The specified attributes are copied into the
underlying map, so modifying the specified attributes parameter after
the call won't change the internal state.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='attribute' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets a user defined attribute without a value. This is useful when
you just want to put a 'mark' attribute. Its value is set to
{@link Boolean#TRUE}.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='attributes' type='xs:string'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Sets the attribute map. The specified attributes are copied into the
underlying map, so modifying the specified attributes parameter after
the call won't change the internal state.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.integration.xbean.SocketAddressFactory -->
  <xs:element name='socketAddress'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Workaround for dealing with inability to annotate java docs of JDK
socket address classes.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='value' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.ssl.SslFilter -->
  <xs:element name='sslFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        An SSL filter that encrypts and decrypts the data exchanged in the session.
Adding this filter triggers SSL handshake procedure immediately by sending
a SSL 'hello' message, so you don't need to call
{@link #startSsl(IoSession)} manually unless you are implementing StartTLS
(see below). If you don't want the handshake procedure to start
immediately, please specify {@code false} as {@code autoStart} parameter in
the constructor.
<p>
This filter uses an {@link SSLEngine} which was introduced in Java 5, so
Java version 5 or above is mandatory to use this filter. And please note that
this filter only works for TCP/IP connections.
<p>

<h2>Implementing StartTLS</h2>
<p>
You can use {@link #DISABLE_ENCRYPTION_ONCE} attribute to implement StartTLS:
<pre>
public void messageReceived(IoSession session, Object message) {
if (message instanceof MyStartTLSRequest) {
// Insert SSLFilter to get ready for handshaking
session.getFilterChain().addFirst(sslFilter);

// Disable encryption temporarilly.
// This attribute will be removed by SSLFilter
// inside the Session.write() call below.
session.setAttribute(SSLFilter.DISABLE_ENCRYPTION_ONCE, Boolean.TRUE);

// Write StartTLSResponse which won't be encrypted.
session.write(new MyStartTLSResponse(OK));

// Now DISABLE_ENCRYPTION_ONCE attribute is cleared.
assert session.getAttribute(SSLFilter.DISABLE_ENCRYPTION_ONCE) == null;
}
}
</pre>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='enabledCipherSuites' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Returns the list of cipher suites to be enabled when {@link SSLEngine}
is initialized.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='enabledProtocols' minOccurs='0' maxOccurs='1'>
          <xs:annotation>
            <xs:documentation><![CDATA[
              Returns the list of protocols to be enabled when {@link SSLEngine}
is initialized.
            ]]></xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='unbounded'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='sslContext' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='autoStart' type='xs:boolean'/>
      <xs:attribute name='needClientAuth' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns <tt>true</tt> if the engine will <em>require</em> client authentication.
This option is only useful to engines in the server mode.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='sslContext' type='xs:string'/>
      <xs:attribute name='useClientMode' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns <tt>true</tt> if the engine is set to use client mode
when handshaking.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='wantClientAuth' type='xs:boolean'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns <tt>true</tt> if the engine will <em>request</em> client authentication.
This option is only useful to engines in the server mode.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.integration.xbean.StandardThreadPool -->
  <xs:element name='standardThreadPool'>
    <xs:complexType>
      <xs:attribute name='maxThreads' type='xs:integer'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.stream.StreamWriteFilter -->
  <xs:element name='streamWriteFilter'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        Filter implementation which makes it possible to write {@link InputStream}
objects directly using {@link IoSession#write(Object)}. When an
{@link InputStream} is written to a session this filter will read the bytes
from the stream into {@link IoBuffer} objects and write those buffers
to the next filter. When end of stream has been reached this filter will
call {@link IoFilter.NextFilter#messageSent(IoSession,WriteRequest)} using the original
{@link InputStream} written to the session and notifies
{@link org.apache.mina.core.future.WriteFuture} on the
original {@link org.apache.mina.core.write.WriteRequest}.
<p/>
This filter will ignore written messages which aren't {@link InputStream}
instances. Such messages will be passed to the next filter directly.
</p>
<p/>
NOTE: this filter does not close the stream after all data from stream
has been written. The {@link org.apache.mina.core.service.IoHandler} should take
care of that in its
{@link org.apache.mina.core.service.IoHandler#messageSent(IoSession,Object)}
callback.
</p>
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name='writeBufferSize' type='xs:integer'>
        <xs:annotation>
          <xs:documentation><![CDATA[
            Returns the size of the write buffer in bytes. Data will be read from the
stream in chunks of this size and then written to the next filter.
          ]]></xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


  <!-- element for type: org.apache.mina.filter.executor.UnorderedThreadPoolExecutor -->
  <xs:element name='unorderedThreadPoolExecutor'>
    <xs:annotation>
      <xs:documentation><![CDATA[
        A {@link ThreadPoolExecutor} that does not maintain the order of {@link IoEvent}s.
This means more than one event handler methods can be invoked at the same
time with mixed order. For example, let's assume that messageReceived, messageSent,
and sessionClosed events are fired.
<ul>
<li>All event handler methods can be called simultaneously.
(e.g. messageReceived and messageSent can be invoked at the same time.)</li>
<li>The event order can be mixed up.
(e.g. sessionClosed or messageSent can be invoked before messageReceived
is invoked.)</li>
</ul>
If you need to maintain the order of events per session, please use
{@link OrderedThreadPoolExecutor}.
      ]]></xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name='queueHandler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='rejectedExecutionHandler' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='threadFactory' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name='unit' minOccurs='0' maxOccurs='1'>
          <xs:complexType>
            <xs:sequence minOccurs='0' maxOccurs='1'><xs:any minOccurs='0' maxOccurs='unbounded'/></xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded'/>
      </xs:sequence>
      <xs:attribute name='corePoolSize' type='xs:integer'/>
      <xs:attribute name='keepAliveTime' type='xs:long'/>
      <xs:attribute name='maximumPoolSize' type='xs:integer'/>
      <xs:attribute name='queueHandler' type='xs:string'/>
      <xs:attribute name='rejectedExecutionHandler' type='xs:string'/>
      <xs:attribute name='threadFactory' type='xs:string'/>
      <xs:attribute name='unit' type='xs:string'/>
      <xs:attribute name='id' type='xs:ID'/>
      <xs:anyAttribute namespace='##other' processContents='lax'/>
    </xs:complexType>
  </xs:element>


</xs:schema>
